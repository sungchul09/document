<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

</body>

<script>
    /*
    IP
    1) IP 프로토콜의 한계
        - 비연결성: 패킷을 받을 대상이 없거나 서비스 불능 상태여도 패킷 전송 (TCP 사용으로 해결)
        - 비신뢰성: 중간에 패킷이 사라지거나, 패킷이 순서대로 안올 수 도 있다. (TCP 사용으로 해결)
        - 프로그램 구분: 같은 IP를 사용하는 서버에서 통신하는 애플리케이션이 둘 이상일 경우 (PORT로 해결)
    2) 클라이언트 패킷 전달: 출발ip, 도착ip, 내용 입력 후 전달
    3) 서버 패킷 전달: 출발ip, 목적ip, 응답 전달
    
    TCP, UDP
    1) 인터넷 프로토콜 스택의 4계층
        - 애플리케이션 계층 - HTTP, FTP
        - 전송계층 - TCP, UDP
        - 인터넷계층 - IP
        - 네트워크 인터페이스 계층
    2) TCP 특징
        - 연결 지향: TCP 3 way handshake
            - 클라이언트 -> 서버: SYN(접속요청)
            - 서버 -> 클라이언트: SYN(접속요청) + ACK(요청수락)
            - 클라이언트 -> 서버: ACK(요청수락)
            - 데이터 전송
        - 데이터 전달 보장: 데이터 전달을 하면 "잘 받았는지" 응답을 꼭 해준다.
        - 순서 보장: 패킷1, 2, 3 순서로 전송 -> 패킷 1, 3, 2로 도착하면 재전송요청을 응답으로 보낸다.
        - 신뢰할 수 있는 프로토콜
        - 현재 대부분 tcp 사용
    3) UDP 특징
        - 기능이 거의 없음
        - 연결지향 - TCP 3 handshake X
        - 데이터 전달 보증 X
        - 순서 보장 X
        - 데이터 전달 및 순서가 보장되지 않지만, 단순하고 빠르다
        - IP와 거의 같다. (PORT, 체크섬 정도만 추가)
        - 애플리케이션에서 추가 작업이 필요하다.
    
    PORT
    1) 같은 IP내에서 프로세스를 구분하는 용도
    2) 0 ~ 65535 할당 가능
    3) 0 ~ 1023: 잘 알려진 포트, 사용하지 않는 것이 좋다.
        - FTP: 20, 21
        - TELNET: 23
        - HTTP: 80
        - HTTPS: 443
    
    DNS
    1) 도메인 명을 IP 주소로 변경해준다.
        - 클라이언트: 도메인 명 google.com를 전달
        - DNS 서버: 200.200.200.2xx로 응답
        - 클라이언트:  200.200.200.2xx로 접속
    
    URL
    1) URI, URL, URN: URI가 큰 범위이고 그 안에 URL, URN이 있다.
        - URI
        - URL: 리소스가 있는 위치를 지정 (ex. test.com:8080/get/name?123)
        - URN: 이름을 부여한 것. (딱히 공부 안해도될듯 ...)
        - URI, URL을 같은 의미로 설명해도 될듯 
        (URI는 URL, URN의 큰 범위이며 URN으로 실제 리소스를 찾는 방법이 보편화되어있지않음.)
    2) URL
        - 프로토콜: http, https, ftp ...
        - 호스트명: www.google.com
        - 포트번호: 8080
        - 패스: /search
        - 쿼리 파라미터: name=hello&type=a
    
    웹브라우저의 요청 흐름
    1) http 메시지 전송
        - 웹브라우저가 http 메시지 생성
        - socket 라이브러리를 통해 전달
            - TCP/IP 연결 (IP, PORT)
            - 데이터 전달
        - TCP/IP 패킷 생성, HTTP 메시지 포함
    2) 클라이언트 - 패킷 생성 및 전달
        - 출발지, 목적지의 ip와 port 및 전송 데이터 tcp/ip 패킷 생성 후 전달
    3) 서버 - 요청 패킷 응답
        - http 응답 메시지 전달
    4) 클라이언트 - HTTP 응답메시지 확인, 데이터 전송 완료

    HTTP
    1) HTTP 메시지에 모든 것을 전송
        - HTML, TEXT, IMAGE, 음성, 영상, 파일, JSON, XML 등 거의 모든 형태 데이터 전송 가능
    2) 서버간에 데이터를 주고 받을 때도 대부분 HTTP 사용 (TCP끼리 통신하는 경우는 거의 없다.)
    3) HTTP는 클라이언트 서버 구조
        - request/response 구조
        - 클라이언트: 서버에 요청을 보내고, 응답 대기
        - 서버: 요청에 대한 결과를 만들어서 응답.
    4) 무상태 프로토콜(Stateless)
        - 상태유지(Stateful): 서버1, 2, ... 999 있으면 무조건 처음 연결한 서버1을 통해서만 응답을 계속 해줘야한다. 다른 서버가 응답을 해줄수없다.
        - 무상태(Stateless): 서버1, 2, ... 999 있으면 무조건 처음 연결한 서버가 응답해주지않아도 된다. 990 개 중 아무 서버가 응답 가능하다. 
            - 갑자기 클라이언트 요청이 증가해도 서버를 대거 투입할 수 있다.
            - 무상태는 응답 서버를 쉽게 바꿀 수 있다. (무한한 서버 증설 가능)
            - 무상태는 스케일아웃(수평확장유리) 특징이 있다.
            - 무상태의 단점(한계)
                - 모든 것을 무상태로 설계할 수 없다. 
                - 로그인 같은 경우 상태 유지를 해야한다.
                - 데이터를 많이 먹긴한다.
    5) 비연결성
        - http는 기본이 연결을 유지하지 않는 모델이다
        - 일반적으로 초 단위 이하의 빠른 속도로 응답한다
        - 1시간 동안 수천명이 서비스를 사용해도 실제 서버에서 동시에 처리하는 요청은 수십개 이하로 매우 작다.
            - 예를들어, 웹 브라우저에서 계속 연속해서 검색 버튼을 누르지는 않는다.
        - 서버 자원을 매우 효율적으로 사용할 수 있다.
        - 비연결성의 단점(한계)
            - TCP/IP 연결을 새로 맺어야 한다 - 3 handshake 시간 추가
            - 웹 브라우저로 사이트를 요청하면 HTML 뿐만 아니라 자바스크립트, CSS, 추가 이미지 등 
            수 많은 자원이 함께 다운로드 된다.
            - 지금은 HTTP 지속 연결(persistent Connections)로 문제 해결
            - HTTP/2, HTTP/3 에서 더 많은 최적화
    6) HTTP 메시지
        - 시작라인(start-line): request-line, status-line
            - request-line: method SP(공백) request-target SP HTTP-version CRLF(엔터)
                - method: GET, POST, PUT, DELETE ... (서버가 수행해야 할 동작을 지정하는 것이다.)
                - request-target: 요청 경로로 절대 경로를 넣는다.
                - http-version: HTTP/1.1, HTTP/2, HTTP/3
            - status-line: HTTP-version SP status-code SP reason-phrase CRLF
                - HTTP-version: HTTP/1.1, HTTP/2, HTTP/3
                - HTTP-code: 200(성공), 400(클라이언트 요청 오류), 500(서버 내부 오류) 등 요청 성공, 실패를 나타냄
                - reason-phrase: 사람이 이해할 수 있는 짧은 상태 코드 설명 글
        - 헤더: header-field로 구성
            - heade-field = field-name ":" OWS(띄어쓰기허용) field-value OWS
            - ex) host: www.google.com
            - 헤더에 http 전송에 필요한 모든 부가 정보가 담겨있다.
            ex) 메시지 body의 내용, body의 크기, 압축, 인증, 요청 클라이언트 정보, 서버 어플리케이션정보, 캐시 관리 정보 등...
        - 바디: 실제 전송할 데이터가 들어간다. 
            - byte로 표현 가능한 모든 데이터 전송 가능
            - HTML, TEXT, IMAGE, 음성, 영상, 파일, JSON, XML 등 거의 모든 형태 데이터 전송 가능
    7) 단순함, 확장 가능
    
    HTTP 기반 프로토콜
    1) TCP: HTTP/1.1, HTTP/2
    2) UDP: HTTP/3
    3) 현재 HTTP/1.1 주로 사용 (HTTP/2, HTTP/3 도 점점 증가 추세)

    HTTP 메서드
    1) GET: 리소스 조회
        - 서버에 전달하고 싶은 데이터는 query를 통해서 전달
        - 메시지 바디를 사용해 데이터를 전달할 수 있지만, 지원하지 않는 곳이 많아서 권장하지 않음.
    2) POST: 요청 데이터 처리, 주로 등록에 사용
        - 리소스 URI에 POST 요청이 오면 요청 데이터를 어떻게 처리할지 리소스마다 따로 정해야한다. (정해진것이 없다.)
        - 주로 전달된 데이터로 신규 리소스 등록, 프로세스 처리, 다른 메서드로 처리하기 애매한 경우에 사용
        - 신규 리소스 등록: ex. 회원가입, 게시글작성, 그외에 프로세스처리 
        - 프로세스 처리: ex. 주문에서 결제완료 -> 배달시작 -> 배달완료 처럼 단순히 값 변경을 넘어 프로세스의 상태가 변경되는 경우
        - 다른 메서드로 처리하기 애매한 경우: ex) JSON으로 조회 데이터를 넘겨야하는데, GET 메서드를 사용하기 어려운 경우. (조회이지만 POST 사용)
    3) PUT: 리소스를 대체, 해당 리소스가 없으면 생성
        -ex) 파일을 폴더에 넣으면 덮어쓰기돼버리거나 새로 생성되는 느낌
    4) PATCH: 리소스 부분 변경
        -ex) 회원 이름을 바꾸는 등 특정 부분만 변경
    5) DELETE: 리소스 삭제
    6) 기타 메서드
        -HEAD: GET과 동일하지마 메시지 부분을 제외하고, 상태 줄과 헤더만 반환
        -OPTIONS: 대상 리소스에 대한 통신 가능 옵션(메서드)을 설명(주로 CORS에서 사용)
        -CONNECT: 대상 자원으로 식별되는 서버에 대한 터널을 설정
        -TRACE: 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트를 수행
    */
</script>

</html>